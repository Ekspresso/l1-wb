Задания блока L1

Теоретические задания:
____________________________________________________________________________________________________

1. Какой самый эффективный способ конкатенации строк?
    До версии Go 1.10 самым эффективным способом конкатенации строк являлось использование bytes.Buffer:
//
package main
import (
	"bytes"
	"fmt"
)
func main() {
	strings := []string{"Hello", ", ", "world ", "!"}
	buffer := bytes.Buffer{}
	for _, val := range strings {
		buffer.WriteString(val)
	}
 
	fmt.Println(buffer.String())
}
//
    С версией Go 1.10 появился более эффективный способ конкатенации строк с использованием strings.Builder 
и предварительным выделением необходимого количества памяти функцией strings.Grow:
//
func concat(x, y string) string {
    var builder strings.Builder
    builder.Grow(len(x) + len(y)) // Эта строка выделяет память
    builder.WriteString(x) //Записывает в builder строку.
    builder.WriteString(y)
    return builder.String()
}
//
____________________________________________________________________________________________________

2. Что такое интерфейсы, как они применяются в Go?
    https://habr.com/ru/company/vk/blog/463063/ - полезная статья с примерами использования интерфейсов.
    Интерфейс - это тип данных, который, в отличие от остальных, представляет не хранимые значения,
а поведение других типов. То есть интерфейс определяет некоторый функционал, не привязанный к конкретной реализации.
Интерфейс не реализует этот функционал.
type имя_интерфейса interface{
    определения_функций
}
    Например:
//
type vehicle interface{
    move()
}
//
    Интерфейс - это своего рода контракт, которому должен соответствовать некоторый тип данных. 
Чтобы тип данных соответствовал определённому интерфейсу, необходимо чтобы он реализовывал, 
в качестве методов, все функции этого интерфейса.
Интерфейсы позволяют определить какую-то обобщенную реализацию без привязки к конкретному типу.
Может быть полезно в случае, когда в программу вводится несколько объектов разного типа, но с общим поведением,
которое реализуется по разному.
    Например:
//
package main
import "fmt"
type Vehicle interface{
    move()
}
func drive(vehicle Vehicle){
    vehicle.move()
}
type Car struct{ }      // 2 разных типа данных с одинаковыми методами поведения, которые реализуются по разному
type Aircraft struct{}
func (c Car) move(){
    fmt.Println("Автомобиль едет")
}
func (a Aircraft) move(){
    fmt.Println("Самолет летит")
}
func main() {
    tesla := Car{}
    boing := Aircraft{}
    drive(tesla)
    drive(boing)
}
//
    Если функция использует в объявлении параметра интерфейсный тип, можно использовать объект любого типа, 
пока он удовлетворяет интерфейсу.
Например в эту функцию можно передать любой тип данных, который будт удовлетворять интерфейсу Stringer
//
type Stringer interface {
    String() string
}
func WriteLog(s fmt.Stringer) {
    log.Println(s.String())
}
//
    Пустой интерфейс interface{} не описывает никакие методы, а значит ему удовлетворяет любой тип данных.
Например в отображениях map[string]interface{} в значениях могут храниться любые произвольные данные,
но для работы с ними необходимо будет сделать обратное приведение типов, т.к. при записи данные становятся типа interface{}.
Может быть использовано, когда работа будет производиться с заранее не известными типами данных.
____________________________________________________________________________________________________

3. Чем отличаются RWMutex от Mutex?
    Mutex защищает доступ к определённым участкам памяти. Он блокирует эту память, программа выполняет все необходимые действия,
затем память разблокируется для дальнейшего использования (Lock и Unlock).
    RWMutex то же самое, что и Mutex, за исключением того, что он даёт немного больше контроля над памятью.
Он позволяет запросить блокировку для чтения (RLock), и она будет предоставлена в случае, если память не заблокирована для записи (Lock).
Таким образом несколько процессов могут считывать из одного участка памяти данные, если в этот момент они не изменяются.
____________________________________________________________________________________________________

4. Чем отличаются буферизированные и не буферизированные каналы?
    https://habr.com/ru/post/490336/ - хорошая статья о каналах
    Немного о каналах:
    Канал — это объект связи, с помощью которого горутины обмениваются данными. 
То есть одна горутина может отправить данные в канал, а другая — считать помещенные в этот канал данные.
Причём, если в горутине присутствует получение данных из канала, то, дойдя до этой строки, выполнение горутины приостановится
до момента появления в канале данных, которые можно считать.
    Та же ситуация происходит и с записью данных в канал. Если горутина отправила данные в канал, то она приостанавливает свою работу до момента, 
пока эти данные из канала не считает другая горутина.
ВСЕГДА НЕОБХОДИМО СЛЕДИТЬ ЗА ТЕМ, ЧТОБЫ КАНАЛ КТО-ТО СЧИТЫВАЛ ПРИ ОТПРАВКЕ ДАННЫХ. Иначе может произойти аварийный выход из программы из-за deadlock.
Канал можно закрыть функцией close(). Нельзя отправлять или читать данные по закрытому каналу.
    Буферизированные и не буферизированные каналы:
Не буферизированный канал - это канал, размер буфера которого равен 0. 
make(chan тип_данных_канала, размер_буфера канала)
    Буферизированный канал - канал с размером буфера >0.
    Когда размер буфера больше 0, горутина не блокируется до тех пор, пока буфер не будет заполнен. 
Для значения буфера 3 необходимо передать в канал 4 значения для его блокировки, при чтении считаются также 4 значения в том порядке, 
в котором они были записаны в канал (очередь)(c<-1, c<-2, c<-3, c<-4. 1<-c, 2<-c, 3<-c, 4<-c). 
Операция чтения на буферизированном канале является жадной, таким образом, как только операция чтения началась, она не будет завершена до полного опустошения буфера. 
Это означает, что горутина будет считывать буфер канала без блокировки до тех пор, пока буфер не станет пустым.
    У буферизированного канала есть len и cap подобно срезам. Длина - это количество не считанных данных из канала. Ёскость - это размер буфера канала.
    У закрытого буферизированного данные, если они не были считаны, всё ещё хранятся в буфере, поэтому их можно считать через цикл for range.
____________________________________________________________________________________________________

5. Какой размер у структуры struct{}{}?
    0 байт. Её размер действительно 0.
____________________________________________________________________________________________________

6. Есть ли в Go перегрузка методов или операторов?
Перегрузка операторов — это способ, с помощью которого операторы могут выполнять операции, определенные пользователями. 
    Операторы ведут себя в соответствии с переданными аргументами. 
Например, в C ++ "+" оператор может использоваться для объединения строк, а также сложения двух целых чисел. Значение «+» также может быть определено пользователем и изменено в соответствии с потребностями программы. 
    В JavaScript операция типа '1' + 1 приведет к выводу строки "11" из-за более высокого приоритета строк. 
    Такие определения недопустимы в Go, операторы работают строго и выполняют операции только с определенными типами данных аргументов.
    В Go также нет перегрузки функций для уменьшения запутанности кода.
    Аналогом перегрузки функций служит использование интерфейсов и нескольких различных типов данных с одноимёнными методами.
____________________________________________________________________________________________________

7. В какой последовательности будут выведены элементы map[int]int?
Пример:
m[0]=1
m[1]=124
m[2]=281
    При переборе карты циклом for range порядок не гарантируется и может отличаться от запуска к запуску программы.
Для того, чтобы порядок перебора был последовательным необходимо дополнительно иметь структуру данных, определяющую этот порядок.
Например, для карты map[int]string можно при занесении значений в карту использовать срез, в который сразу будут записываться ключи:
//
import "sort"
var m map[int]string
var keys []int
for k := range m {
    keys = append(keys, k)
}
sort.Ints(keys)
for _, k := range keys {
    fmt.Println("Key:", k, "Value:", m[k])
}
//
____________________________________________________________________________________________________

8. В чем разница make и new?
--'new’ возвращает указатель вместо значения возвращаемое функцией ‘make’.
--'new’ выделяет место в памяти без инициализации.
--‘make’ имеет вариадический аргумент ‘size’.
--‘make’ выделяет память и инциализирует только объекты типов: slice, map, or chan.
var a = new(T), где Т - тип данных
s := make([]int, 2,3) - объявление среза с длинной и ёмкостью.
____________________________________________________________________________________________________

9. Сколько существует способов задать переменную типа slice или map?
3 способа: make, new и литералы
____________________________________________________________________________________________________

10. 